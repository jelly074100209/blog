# 聚合

聚合可能是领域驱动设计中最难的构建块了。它们难以理解，并且难以正确设计。但不用担心，我们会帮助你。不过，在进入聚合之前，我们首先需要深入了解一些概念：事务和并发策略。

## 介绍

如果你使用过电子商务应用，则可能已经遇到过与数据库中数据不一致有关的错误。例如，考虑一个总额为 99.99 美元的购物订单，该订单与订单中每行总金额的总和 89.99 美元不匹配。那这笔额外的 10 美元来自哪里？

或者，考虑一个为影院售卖电影票的网站。有一个剧院有 100 个可用座位，并且在电影成功上映之后，每个人都在网站上等待购票。一旦你开售，一切都会快速进行，最终你会以某种方式卖出了 102 张门票。你可能已经指定只有 100 个座位，但是由于某种原因你超过了该阈值。

你可能有使用像 JIRA 或者 Redmine 之类的追踪系统的经验。考虑一个开发，QA，以及一个产品经理的小组。如果每个人都在计划会议中，围绕用户故事分类和移动它们然后保存，这会发生什么问题？最终的待办项或者
冲突优先级可能会是团队中最后保存它的人。

一般来说，当我们用一种非原子方式处理持久化机制时，会发生数据不一致。一个例子就是，当你发送三个查询请求到数据库，它们中的一些正常一些不正常。数据库的最终状态就会不一致。有时，你希望这三个查询请求全部成功或者失败，那么可以用事务。不过要注意，正如你将在这章看到的，并不是所有非一致性问题都用事务解决。事实上，有时一些数据不一致情况需要锁或者并发策略来解决。这些工具可能会影响你的应用性能，所以请注意权衡。

你可能认为这些数据不一致情况仅仅发生在数据库，但实际不是这样。例如，如果我们使用一个面向文档数据库（诸如 Elasticsearch），两个文档间数据可能会不一致。此外，大多数 NoSQL 持久化存储系统都不支持 ACID 事务。这意味着你不能在单个操作上持久化或更新多个文档。因此，如果我们对 Elasticsearch 作出不同请求，则可能会失败，从而使保存在 Elasticsearch 中的数据不一致。

保证数据一致性是一个挑战。不将基础设施问题泄漏到领域中是一个更大的挑战。聚合可以帮助你处理这些问题。

## 关键概念

持久化引擎，特别是数据库，具有一些解决数据不一致的功能：ACID，约束，引用完整性，锁，并发控制和事务。在使用聚合之前，让我们回一下这些概念。

这些概念的大多数在互联网上都是对公开开放的。我们想感谢在 Oracle，PostgreSQL，以及 Doctrine 的人，用他们的文档做出了令人惊叹的工作。他们细致地定义和解释了这些重要内容，并且不是重复造轮子，我们整理了一些官方解释以分享给你。

### ACID (事务管理)

正如在上一节中讨论的，ACID 代表原子性 (atomicity），一致性 (consistency)，隔离性 (isolation)，以及持久性 (durability)。根据 MySQL 词汇表：

> 这些属性都是数据库系统所需要的，并且都与事务概念紧密相关。例如，MySQL InnoDB 引擎的事务功能遵循 ACID 原则。
>  
> 事务是**原子**工作单元，它可以被提交和回滚。当一个事务都数据库做出多种改变，要么当事务提交时所有改变都成功，要么当事务回滚时所有改变都失败。
>  
> 在每个提交或回滚之后，以及在事务的进程中，数据库总是保持一个**一致**状态。如果要跨越多个表更新了相关数据，那么查询将看到所有旧值或所有新值，而不是新旧值的混合。
>  
> 事务进程时，受彼此**隔离**保护。他们互相之间不能干扰，也不能看到彼此未提交的数据。这种隔离是通过锁定机制实现的。有经验的用户在确定事务不会相互干扰时，可以调整隔离级别，降低保护措施以提高性能和并发。
>  
> 事务执行结果是**持久**的：一旦操作提交成功，不论断电，系统崩溃，竞争条件，或者其它许多非数据库应用程序容易受到的潜在危险，事务所作出的改变都是安全的。持久性通常涉及到写入磁盘存储，并具有一定数量的冗余以防止写作操作期间出现电源故障或软件崩溃。

### 事务 (Transactions)

依据 PostgreSQL 8.2.23 文档:
> 事务是所有数据库系统的基础概念。事务的精髓就是，它将多个步骤捆绑成单个“全有或全无”的操作。步骤之间的中间状态对于其他并发事务是不可见的，并且如果发生某些故障导致该事务无法完成，则所有步骤都不会影响数据库。

例如，考虑一个银行数据库，其包含各种客户账户余额以及分行的总存储余额。假设我们记录从 Alice 的账户到 Bob 的账户之间的 100 美元转账。简单来说，SQL 命令看起来就像这样：

```sql
UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice';

UPDATE branches SET balance = balance - 100.00 WHERE name = (SELECT branch_name FROM accounts WHERE name ='Alice');

UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Bob';

UPDATE branches SET balance = balance + 100.00 WHERE name = (SELECT branch_name FROM accounts WHERE name ='Bob');
```

这些命令的详细信息在这里并不重要，重要的是，要完成这个简单的操作，需要涉及到几个独立的更新。我们银行的管理人员希望确保所有的这些更新都发生了，或者什么都没发生。系统故障当然不会导致 Bob 收到不是从 Alice 那里扣除的 100 美元。如果在没有 Bob 信用的情况下借出，Alice 也永远不会是一个满意的客户。我们需要保证，如果在操作过程中出现问题，到目前为止执行的任何操作都不会生效。将更新编排到一个事务中为我们提供了保证。事务是原子的：从其它事务的角度来看，它要么完全发生，要么根本不发生。

我们也想确保，一旦事务完成并且由数据库系统确认，该事务将确定被永久记录，并且之后不久系统发生崩溃也不会丢失。例如，我们正在记录 Bob 提取的现金，我们不希望他账户的借方在他走出银行大门后的崩溃中消失的任何可能性。事务数据库保证在报告事务完成之前，其所做的所有更新都记录在永久性的存储中（即在磁盘上）。

事务型数据库另一个重要属性与原子更新的概念密切相关：当多个事务同时运行时，每个都不应该看到其它事务未完成的改变。例如，如果一项事务正忙于汇总所有分行的余额，那么它将不会包括 Alice 所在分行的这笔借款，也不会包括 Bob 所在分行的这笔贷款，反之亦然。所以事务不仅必须是对数据库的永久影响，还必须视它们发生时的可见性而定。迄今为止，一个打开的事务进行更新时对其它事务是不可见的，直到该事务完成为止，随后所有更新同时可见。

在 PostgreSQL中，例如，一个事务由 BEGIN 和 COMMIT 包裹的 SQL 命令组成。所以我们的银行事务实际看起来像这样：

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice';
-- etc etc
COMMIT;
```

如果在事务中途，我们决定不提交（也许我们刚刚发现 Alice 的余额为负），则可以发出 ROLLBACK 命令代替 COMMIT，并且到目前为止所有更新都将被取消。

PostgreSQL 实际上将每个 SQL 语句都当作事务执行。如果你没有声明一个 BEGIN 命令，之后每个单独的语句都会被 BEGIN 和 COMMIT 包裹（如果成功的话）。一组用 BEGIN 和 COMMIT 包裹的语句有时候被称为事务块。

所有这些都发生在一个事务块内，所以任何一个事务对其它数据库会话都不可见。当你提交事务块时，提交动作作为一个单元对其它会话可见，而回滚动作则不可见。

### 隔离级别 (Isolation Levels)

依据 MySQL Glossary，事务隔离是：
> 数据库处理过程的基本功能之一。隔离是缩写 ACID 中的 "I"。隔离级别是一种设置，用于在多个事务同时进行更新和执行查询时微调性能与结果可靠性，一致性和可重复性之间的平衡。
>  
> 从最高级别的一致性和最低程度的保护，InnoDB 支持的隔离级别是：SERIALIZABLE（序列化），REPEATABLE READ（重复读），READ COMMITTED（读提交），和 READ UNCOMMITTED（读未提交）。
>  
> 对于 InnoDB 表，大多数用户沿用默认隔离级别 REPEATABLE READ 处理所有操作。资深用户可能会选择 READ COMMITTED 级别，这是因为他们在 OLTP 处理中或在数据仓库操作过程突破了可伸缩性的界限，在这种情况下，微小的不一致不会影响大量数据的合计结果。边缘的级别（SERIALIZABLE 和 READ UNCOMMITTED）将处理行为更改为很少使用的程度。

### 引用完整性 (Referential Integrity)

依据 MySQL Glossary，引用完整性是：
> 一种维护数据保持一致格式的技术，是 ACID 哲学的一部分。特别是，不同表的数据通过使用外键约束来保持一致性，这可以阻止事件的改变，或者自动广播这些改变给所有相关的表。相关机制包括一致性约束（防止重复插入错误值）以及 NOT NULL 约束（防止空值被错误插入）。

### 锁 (Locking)

依据 MySQL Glossary，锁是：
> 一种保护事务中正在查看或更改的被其它事务查询和更改的数据的系统（The system of protecting a transaction from seeing or changing data that is being queried or changed by other transactions）。锁定策略必须在数据库操作的可靠性和一致性（ACID 哲学原则）与良好并发所需的性能之间取得平衡。调整锁定策略通常涉及选择隔离级别，并确保所有数据库操作对于该隔离级别而言都是可靠的。

### 并发 (Concurrency)

依据　MySQL Glossary，并发是：
> 多个操作在相互不干涉的情况下（在数据库术语中指事务）同时运行的能力。并发还与性能有关，因为理想情况下，使用有效的锁机制来保护多个同时进行的事务时，可以在最小的性能开销的情况下工作。

#### 悲观并发控制 (PCC)

Clinton Gormley 和 Zachary Tong 在 《Elasticsearch 权威指南》一书中讨论过 PCC：
> 其广泛使用于关系型数据库，这种方法假设更新有可能发生冲突，并且

##### 使用 Doctrine

#### 乐观并发控制 (OCC)

##### 使用 Elasticsearch

##### 使用Doctrine

## 使用聚合

### Martin Fowler 怎么说

### 维基百科 怎么说

## 为什么要聚合

## 一点历史

## 聚合剖析

## 聚合设计原则

### 基于业务真正不变条件设计聚合

### 小聚合 Vs. 臃肿聚合

### 通过标识引用其它实体

### 每个事务和请求只更新一个聚合

### 应用服务示例：用户与愿望

#### 非不变性，两个聚合

#### 每个用户不超过三个愿望

##### 悲观并发控制

##### 乐观并发控制

## 事务

## 小结
