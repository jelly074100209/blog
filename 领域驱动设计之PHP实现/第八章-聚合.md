# 聚合

聚合可能是领域驱动设计中最难的构建块了。它们难以理解，并且难以正确设计。但不用担心，我们会帮助你。不过，在进入聚合之前，我们首先需要深入了解一些概念：事务和并发策略。

## 介绍

如果你使用过电子商务应用，则可能已经遇到过与数据库中数据不一致有关的错误。例如，考虑一个总额为 99.99 美元的购物订单，该订单与订单中每行总金额的总和 89.99 美元不匹配。那这笔额外的 10 美元来自哪里？

或者，考虑一个为影院售卖电影票的网站。有一个剧院有 100 个可用座位，并且在电影成功上映之后，每个人都在网站上等待购票。一旦你开售，一切都会快速进行，最终你会以某种方式卖出了 102 张门票。你可能已经指定只有 100 个座位，但是由于某种原因你超过了该阈值。

你可能有使用像 JIRA 或者 Redmine 之类的追踪系统的经验。考虑一个开发，QA，以及一个产品经理的小组。如果每个人都在计划会议中，围绕用户故事分类和移动它们然后保存，这会发生什么问题？最终的待办项或者
冲突优先级可能会是团队中最后保存它的人。

一般来说，当我们用一种非原子方式处理持久化机制时，会发生数据不一致。一个例子就是，当你发送三个查询请求到数据库，它们中的一些正常一些不正常。数据库的最终状态就会不一致。有时，你希望这三个查询请求全部成功或者失败，那么可以用事务。不过要注意，正如你将在这章看到的，并不是所有非一致性问题都用事务解决。事实上，有时一些数据不一致情况需要锁或者并发策略来解决。这些工具可能会影响你的应用性能，所以请注意权衡。

你可能认为这些数据不一致情况仅仅发生在数据库，但实际不是这样。例如，如果我们使用一个面向文档数据库（诸如 Elasticsearch），两个文档间数据可能会不一致。此外，大多数 NoSQL 持久化存储系统都不支持 ACID 事务。这意味着你不能在单个操作上持久化或更新多个文档。因此，如果我们对 Elasticsearch 作出不同请求，则可能会失败，从而使保存在 Elasticsearch 中的数据不一致。

保证数据一致性是一个挑战。避免将基础设施问题泄漏到领域中是一个更大的挑战。聚合可以帮助你处理这些问题。

## 关键概念

持久化引擎，特别是数据库，具有一些解决数据不一致的功能：ACID，约束，引用完整性，锁，并发控制和事务。在使用聚合之前，让我们回一下这些概念。

这些概念的大多数在互联网上都是对公开开放的。我们想感谢在 Oracle，PostgreSQL，以及 Doctrine 的人，用他们的文档做出了令人惊叹的工作。他们细致地定义和解释了这些重要内容，并且不是重复造轮子，我们整理了一些官方解释以分享给你。

### ACID (事务管理)

正如在上一节中讨论的，ACID 代表原子性 (atomicity），一致性 (consistency)，隔离性 (isolation)，以及持久性 (durability)。根据 MySQL 词汇表：

> 这些属性都是数据库系统所需要的，并且都与事务概念紧密相关。例如，MySQL InnoDB 引擎的事务功能遵循 ACID 原则。
>  
> 事务是**原子**工作单元，它可以被提交和回滚。当一个事务都数据库做出多种改变，要么当事务提交时所有改变都成功，要么当事务回滚时所有改变都失败。
>  
> 在每个提交或回滚之后，以及在事务的进程中，数据库总是保持一个**一致**状态。如果要跨越多个表更新了相关数据，那么查询将看到所有旧值或所有新值，而不是新旧值的混合。
>  
> 事务进程时，受彼此**隔离**保护。他们互相之间不能干扰，也不能看到彼此未提交的数据。这种隔离是通过锁定机制实现的。有经验的用户在确定事务不会相互干扰时，可以调整隔离级别，降低保护措施以提高性能和并发。
>  
> 事务执行结果是**持久**的：一旦操作提交成功，不论断电，系统崩溃，竞争条件，或者其它许多非数据库应用程序容易受到的潜在危险，事务所作出的改变都是安全的。持久性通常涉及到写入磁盘存储，并具有一定数量的冗余以防止写作操作期间出现电源故障或软件崩溃。

### 事务 (Transactions)

依据 PostgreSQL 8.2.23 文档:
> 事务是所有数据库系统的基础概念。事务的精髓就是，它将多个步骤捆绑成单个“全有或全无”的操作。步骤之间的中间状态对于其他并发事务是不可见的，并且如果发生某些故障导致该事务无法完成，则所有步骤都不会影响数据库。

例如，考虑一个银行数据库，其包含各种客户账户余额以及分行的总存储余额。假设我们记录从 Alice 的账户到 Bob 的账户之间的 100 美元转账。简单来说，SQL 命令看起来就像这样：

```sql
UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice';

UPDATE branches SET balance = balance - 100.00 WHERE name = (SELECT branch_name FROM accounts WHERE name ='Alice');

UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Bob';

UPDATE branches SET balance = balance + 100.00 WHERE name = (SELECT branch_name FROM accounts WHERE name ='Bob');
```

这些命令的详细信息在这里并不重要，重要的是，要完成这个简单的操作，需要涉及到几个独立的更新。我们银行的管理人员希望确保所有的这些更新都发生了，或者什么都没发生。系统故障当然不会导致 Bob 收到不是从 Alice 那里扣除的 100 美元。如果在没有 Bob 信用的情况下借出，Alice 也永远不会是一个满意的客户。我们需要保证，如果在操作过程中出现问题，到目前为止执行的任何操作都不会生效。将更新编排到一个事务中为我们提供了保证。事务是原子的：从其它事务的角度来看，它要么完全发生，要么根本不发生。

我们也想确保，一旦事务完成并且由数据库系统确认，该事务将确定被永久记录，并且之后不久系统发生崩溃也不会丢失。例如，我们正在记录 Bob 提取的现金，我们不希望他账户的借方在他走出银行大门后的崩溃中消失的任何可能性。事务数据库保证在报告事务完成之前，其所做的所有更新都记录在永久性的存储中（即在磁盘上）。

事务型数据库另一个重要属性与原子更新的概念密切相关：当多个事务同时运行时，每个都不应该看到其它事务未完成的改变。例如，如果一项事务正忙于汇总所有分行的余额，那么它将不会包括 Alice 所在分行的这笔借款，也不会包括 Bob 所在分行的这笔贷款，反之亦然。所以事务不仅必须是对数据库的永久影响，还必须视它们发生时的可见性而定。迄今为止，一个打开的事务进行更新时对其它事务是不可见的，直到该事务完成为止，随后所有更新同时可见。

在 PostgreSQL中，例如，一个事务由 BEGIN 和 COMMIT 包裹的 SQL 命令组成。所以我们的银行事务实际看起来像这样：

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice';
-- etc etc
COMMIT;
```

如果在事务中途，我们决定不提交（也许我们刚刚发现 Alice 的余额为负），则可以发出 ROLLBACK 命令代替 COMMIT，并且到目前为止所有更新都将被取消。

PostgreSQL 实际上将每个 SQL 语句都当作事务执行。如果你没有声明一个 BEGIN 命令，之后每个单独的语句都会被 BEGIN 和 COMMIT 包裹（如果成功的话）。一组用 BEGIN 和 COMMIT 包裹的语句有时候被称为事务块。

所有这些都发生在一个事务块内，所以任何一个事务对其它数据库会话都不可见。当你提交事务块时，提交动作作为一个单元对其它会话可见，而回滚动作则不可见。

### 隔离级别 (Isolation Levels)

依据 MySQL Glossary，事务隔离是：
> 数据库处理过程的基本功能之一。隔离是缩写 ACID 中的 "I"。隔离级别是一种设置，用于在多个事务同时进行更新和执行查询时微调性能与结果可靠性，一致性和可重复性之间的平衡。
>  
> 从最高级别的一致性和最低程度的保护，InnoDB 支持的隔离级别是：SERIALIZABLE（序列化），REPEATABLE READ（重复读），READ COMMITTED（读提交），和 READ UNCOMMITTED（读未提交）。
>  
> 对于 InnoDB 表，大多数用户沿用默认隔离级别 REPEATABLE READ 处理所有操作。资深用户可能会选择 READ COMMITTED 级别，这是因为他们在 OLTP 处理中或在数据仓库操作过程突破了可伸缩性的界限，在这种情况下，微小的不一致不会影响大量数据的合计结果。边缘的级别（SERIALIZABLE 和 READ UNCOMMITTED）将处理行为更改为很少使用的程度。

### 引用完整性 (Referential Integrity)

依据 MySQL Glossary，引用完整性是：
> 一种维护数据保持一致格式的技术，是 ACID 哲学的一部分。特别是，不同表的数据通过使用外键约束来保持一致性，这可以阻止事件的改变，或者自动广播这些改变给所有相关的表。相关机制包括一致性约束（防止重复插入错误值）以及 NOT NULL 约束（防止空值被错误插入）。

### 锁 (Locking)

依据 MySQL Glossary，锁是：
> 一种保护事务中正在查看或更改的被其它事务查询和更改的数据的系统（The system of protecting a transaction from seeing or changing data that is being queried or changed by other transactions）。锁定策略必须在数据库操作的可靠性和一致性（ACID 哲学原则）与良好并发所需的性能之间取得平衡。调整锁定策略通常涉及选择隔离级别，并确保所有数据库操作对于该隔离级别而言都是可靠的。

### 并发 (Concurrency)

依据　MySQL Glossary，并发是：
> 多个操作在相互不干涉的情况下（在数据库术语中指事务）同时运行的能力。并发还与性能有关，因为理想情况下，使用有效的锁机制来保护多个同时进行的事务时，可以在最小的性能开销的情况下工作。

#### 悲观并发控制 (PCC)

Clinton Gormley 和 Zachary Tong 在 《Elasticsearch 权威指南》一书中讨论过 PCC：
> 其广泛使用于关系型数据库，这种方法假设更新有可能发生冲突，并因此阻止对资源访问以防止冲突。一个典型的例子就是在读取一行数据之前将其锁定，以确保只有设置锁的线程才可以更新这行数据。

##### 使用 Doctrine

依据 Doctrine 2 ORM Documentation 关于锁的支持部分：
> Doctrine 2 原生地提供悲观与乐观锁策略的支持。这样可以对应用程序中的实体所需的锁种类进行非常细粒度的控制。

依据 Doctrine 2 ORM Documentation 关于悲观锁的介绍：
> Doctrine 2 在数据库层面支持悲观锁。没有尝试在 Doctrine 内部实现悲观锁定，而是使用了 vendor-speicific 和 ANSI-SQL 命令来获取行级锁。每个 Doctrine 实体都可以是悲观锁的一部分，使用此功能不需要特殊的元数据。
>  
> 不过，要使悲观锁起作用，你必须禁用数据库的自动提交模式（Auto-Commit Mode），并使用显式数据划分（Explicit Transaction Demarcation）在悲观锁用例周围启动事务。如果你试图获取悲观锁但事务没有运行，则 Doctrine 2 会发生异常。

Doctrine 2 当前支持两种悲观锁模式：

- 悲观写模式 `Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE`，锁定底层数据库行以进行并发读写操作。
- 悲观读模式 `Doctrine\DBAL\LockMode::PESSIMISTIC_READ`，锁定其它尝试更新或者写模式行锁的并发请求。

你可以在以下三种场景使用悲观锁：

- 使用 `EntityManager#find($className, $id, \Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE)` 或者 `EntityManager#find($className, $id, \Doctrine\DBAL\LockMode::PESSIMISTIC_READ)`
- 使用 `EntityManager#lock($entity,\Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE)` 或者 `EntityManager#lock($entity,\Doctrine\DBAL\LockMode::PESSIMISTIC_READ)`
- 使用 `Query#setLockMode(\Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE)` 或者 `Query#setLockMode(\Doctrine\DBAL\LockMode::PESSIMISTIC_READ)`

#### 乐观并发控制 (OCC)

依据维基百科：
> 乐观并发控制（OCC）是一种并发控制方法，应用于事务系统，例如关系型数据库以及软件事务内存。OCC 假设多个事务可以频繁完成而不互相干扰。在运行时，事务使用数据资源而不用获取这些资源的锁。在提交前，
每个事务都会验证没有其他事务修改了已读取的数据。如果检查显示有冲突的修改，提交中的事务将回滚并可以重新启动。OCC 由 H.T.Kung 首次提出。
>  
> OCC 通常用于数据抢占较少的环境。当冲突很少发生时，事务可以完成而无需管理锁。也不必让事务等待其他事务的锁被清除，从而导致吞吐量比其他并发控制方法更高。但是，如果数据资源抢占频繁，那么重复重启事务的成本会严重损害性能。通常认为其他并发控制方法在这些条件下有更好的性能。但是，基于锁的"悲观"方法也会带来较差的性能，因为即使避免了死锁，锁也会极大地限制有效的并发性。

##### 使用 Elasticsearch

依据 Elasticsearch: The Definitive Guide，当 Elasticsearch 使用 OCC 时：
> 这种方式假设冲突不可能发生，并且不会阻止尝试操作。但是，如果在读写之间修改了基础数据，则更新会失败。然后由应用程序决定如何解决冲突。例如，它可以使用新数据重新尝试更新，也可以将情况报告给用户。
>  
> Elasticsearch 是分布式的。当文档创建，更新，或者删除时，新版本的文档必须复制到集群中的其它节点。Elasticsearch 同时是异步和并发的，意思就是这些复制请求是并行发送的，并且它们到达目的地是失序的。Elasticsearch 需要一种方法来确保老版本的文档永远不会覆盖更新的版本。
>  
> 每个文档都有一个 _version 数字，无论何时文档更新，它就会自动增长。Elasticsearch 使用这个 _version 数字来确保按正确的顺序应用更改。如果一个更老的版本先于新版本到达，它可以直接被忽略。
>  
> 我们可以利用 _version 数字来确保应用程序产生的更改冲突不会导致数据丢失。我们通过指定想要更改的文档版本数字来做到。如果版本不是当前的，则我们的请求失败。

让我们新建一个 blog post：

```text
PUT /website/blog/1/_create
{
    "title": "My first blog entry",
    "text": "Just trying this out..."
}
```

回复的 body 告诉我们新创建的文档有一个 _version 值 1。现在想象我们需要编辑这个文档：我们加载数据到一个 web 表单，做出更改，并且保存新版本。

首先我们重新查询该文档：

```text
GET /website/blog/1
```

回复的 body 包含相同的 _version 值 1:

```json
{
    "index": "website",
    "type": "blog",
    "id": "1",
    "version": 1,
    "found": true,
    "_source": {
    "title": "My first blog entry",
    "text": "Just trying this out..."
    }
}
```

现在，当尝试通过重新查询出来的文档保存我们的更改，我们要指定这个将被更改的版本。我们希望这个更新仅仅在当前文档的 _version 是 1 时才成功：

```text
PUT /website/blog/1?version=1
{
    "title": "My first blog entry",
    "text": "Starting to get the hang of this..."
}
```

请求成功后，回复的 body 告诉我们 _version 已经增加到 2:

```json
{
    "index": "website",
    "type": "blog",
    "id": "1",
    "version": 2,
    "created": false
}
```

但是，如果我们运行同一个索引请求，仍然指定 `version=1`，Elasticsearch 会回复一个 409 Conflict HTTP 响应代码，body 如下：

```json
{
    "error": {
        "root_cause": [{
            "type": "version_conflict_engine_exception",
            "reason":
                "[blog][1]: version conflict,current[2],provided[1]",
            "index": "website",
            "shard": "3"
        }],
        "type": "version_conflict_engine_exception" ,
        "reason": "[blog][1]:version conflict,current [2],provided[1]",
        "index": "website",
        "shard": "3"
    },
    "status": 409
}
```

它告诉我们当前文档的 _version 值在 Elasticsearch 中是 2，但我们指定更新的版本是 1。

现在我们要做什么取决于我们的应用程序要求。我们可以告诉用户，其他人已经对文档进行了更改，并在再次尝试保存更改之前先进行检查。另外，就像前面例子的 stock_count widget 一样，我们可以检索最新的文档并尝试重新应用更改。

所有更新或者删除一个文档的 API 接受一个版本参数，它允许你将 OCC 仅应用于有意义的代码部分。

##### 使用Doctrine

依据 Doctrine 2 ORM Documentation 关于 乐观锁的部分：

> 数据库事务在单个请求期间的并发控制是没问题的。但是，一个数据库事务不应该跨越请求，即所谓的用户思考时间（user think time）。因此一个长时间运行的“业务事务”

## 使用聚合

### Martin Fowler 怎么说

### 维基百科 怎么说

## 为什么要聚合

## 一点历史

## 聚合剖析

## 聚合设计原则

### 基于业务真正不变条件设计聚合

### 小聚合 Vs. 臃肿聚合

### 通过标识引用其它实体

### 每个事务和请求只更新一个聚合

### 应用服务示例：用户与愿望

#### 非不变性，两个聚合

#### 每个用户不超过三个愿望

##### 悲观并发控制

##### 乐观并发控制

## 事务

## 小结
