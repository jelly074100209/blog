# 第六章 领域事件

软件事件即系统中其它组件感兴趣的事物。PHP 程序员工作中普遍不使用事件，因为这不是该语言的特性。不过，现在更常见的是，新的框架和库采用它们来提供一种新的解耦，重用和加速代码的途径。

领域事件是领域发生改变时相关的事件。领域事件即发生在领域内的事件，是领域专家所关心的。

在领域驱动设计中，领域事件是基础构建块，它们可以：

- 与其它界限上下文通讯
- 提高性能和可扩展性，推进最终一致性
- 作为历史归档记录

领域事件的本质是异步通信。有关此主题的详细信息，我们推荐 Gregor Hohpe 和 Bobby Woolf 《企业集成模式：设计，构建及部署消息传递解决方案》一书。

## 简介

假设有一个 Javascript 2D 平台游戏，在屏幕上同时有大量不同组件交互。其中一个组件表示剩余生命值，另一个显示所有得分，还有一个显示完成当前等级还剩余的时间。每次你的角色跳到敌人身上，分数就会增加。当你的得分高于一个分数值时，就会获取额外一条命。当你的角色捡起一把钥匙，一扇门通常就会打开。但是所有这些组件是如何相互交互的呢？此场景最佳构架又是什么？

这里有两个可选的方案：第一种是每个组件与它所连接的组件结合起来。不过，在上面的例子中，意味着有大量组件耦合在一起，每个额外的功能增加都需要开发者修改代码。但你还记得**开闭原则（OCP）**吗？增加一个新的组件不应该使它必须更新第一个组件，这会有太多要维护的工作。

第二种，更好的方法，就是将所有组件连接到一个单独的对象上，该对象处理游戏中所有重要的事件。它接收来自每个组件的事件并转发给特定的组件。例如，得分组件可能对一个 `EnemyKilled` 事件感兴趣，而 `LifeCaptered` 事件对玩家实体和剩余生命数组件相当有用。通常这种方式，所有组件与一个管理所有通知的单独组件耦合。使用这种方法，增加或者移除组件都不会影响现有的组件。

当开发一个单体应用时，事件对于解耦组件非常有用。当用分布式方式来开发整个领域时，事件对于领域中发挥作用的每个服务或者应用之间的解耦相当有用。关键点是一样的，但规模却不同。

## 定义

领域事件是一种特殊类型的事件，用来通知本地或者远程领域限界上下文的变化。
Vaughn Vernon 定义领域事件为：
> 领域中发生的事情。

Eric Evans 定义领域事件为:
> 领域事件即领域模型中一个完整的部分，是领域中发生的事件的表现形式。忽然不相碰的领域活动，同时明确领域专家希望追踪的，或者被通知的事件，或与其它领域对象状态改变有关的事件。

Martin Flower 定义领域事件为：
> 一类捕获影响领域的感兴趣的记录。

在 web 应用里的领域事件例子有`用户注册`，`订货`，`转移用户`以及`添加产品`等。

### 小故事

在一家售票代理机构中，运营经理决定提高 U2 秀节目的价格。她进入后台，编辑该节目。一个`ShowPriceChanged` 领域事件被发布，并且在同一事务里将新的节目价格持久到数据库中。

一个批处理进程获取该领域事件并它投递到 `RabbitMQ` 队列中。领域事件被成成两个队列：一是同一个本地限界上下文，另一个远程事件用于商务智能目的。

在第一个队列中，一个工作进程通过事件里的 ID 检索相应的节目，并将其推送到 Elasticsearch 服务器，从而使得用户在搜索时可以看到最新价格。

在第二个队列中，另一个进程将信息插入到一个日志服务器或者数据池，在这可以运行报表或者数据挖掘进程。

一个不能使用领域事件集成到系统的外部应用可以通过本地限界上下文提供的 REST API，访问所有的 ShowPriceChanged 事件。

如你所见，领域事件在处理最终一致性和整合不同限界上下文时非常有用。聚合创建并发布事件。订阅者可以存储事件以及之后转发它们给其它远程订阅者。

### 隐喻

星期二我们去巴布饭店吃饭，用信用卡支付。这可能被建模为一个事件，事件类型为 "下单"，主题是 "我的信用卡", 发生时间为 "星期二"。如果巴布饭使用旧的手动系统，直到周五才传输交易，那么交易将在周五生效。

事情就这样发生了。并不是所有事情都有意义，一些值得记录但并不会发生反应。然而，一般是最感兴趣的事情才发生反应。许多需要对感兴趣的事件做出反应。多数情况下你需要知道为什么一个系统会做出这样的反应。

通过将系统的输入传输到领域事件流中，你可以记录所有的系统输入。这有助于你组织你的处理逻辑，还允许你保留系统输入的审核日志。

> 练习
尝试在你当前的领域中定位潜在的领域事件

### 真实案例

在进入了解领域事件的细节之前，让我们来看一个真实的领域事件实例，以及它们是怎样对我们的应用和整个领域起到帮助的。

让我们考虑一个简单的 Application Service，新用户注册，例如一个电子商务上下文。Application Service 会在其它章节阐述，所以不必在表面上操心太多。相反的，仅需要关注执行方法：

```php
class SignUpUserService implements ApplicationService
{
    private $userRepository;
    private $userFactory;
    private $userTransformer;

    public function __construct(
        UserRepository $userRepository,
        UserFactory $userFactory,
        UserTransformer $userTransformer
    )
    {
        $this->userRepository = $userRepository;
        $this->userFactory = $userFactory;
        $this->userTransformer = $userTransformer;
    }

    /**
     * @param SignUpUserRequest $request
     * @return User
     * @throws UserAlreadyExistsException
     */
    public function execute(SignUpUserRequest $request)
    {
        $email = $request->email();
        $password = $request->password();
        $user = $this->userRepository->userOfEmail($email);
        if ($user) {
            throw new UserAlreadyExistsException();
        }
        $user = $this->userFactory->build(
            $this->userRepository->nextIdentity(),
            $email,
            $password
        );
        $this->userRepository->add($user);
        $this->userTransformer->write($user);
    }
}
```

如上所示，Application Service 部分会检查用户是否存在。如果不存在，则会创建一个新用户并添加到 `UserRepository` 中。

现在考虑一个附加需求：一个新用户在注册时需要用邮件提醒。不需要想太多，首先我们想到的方法就是更新 Application Service，加入一段可以完成这项工作的代码，可能是 `EmailSender` 这种在添加方法之后运行的代码。不过，现在让我们考虑另一种方法。

触发一个 `UserRegistered` 事件，另一个组件监听到后发送邮件怎么样？这种新方法有一些非常酷的好处。首先，在新用户注册时，我们不需要每次再去更新 Application Service 的代码。其次，它更易于测试。Application Service 也变得更简单。每次有新的动作开发时，我们仅需要为此动作写测试用例。

后来在同一个电子商务项目中，我们被告知集成一个非 PHP 编写的开源游戏化平台。每次用户在我们的电子商务上下文下单或者浏览产品时，他们可以在他们的电子商务用户主页上看到所获取的徽章或者被邮件通知到。我们该如何为此问题建模呢？

按照第一种方法，我们将用之前确认电子邮件的方法来更新应用服务，来整合到新的平台中。使用领域事件的方法，我们可以为 `UserRegistered` 创建另一个 `listener` 事件，该事件可以用 REST 或者 SOA 的方式连接到游戏平台。更妙的是，它可以将事件放到 RabbitMQ 这样的消息队列，以便游戏限界上下文可以订阅并自动收到通知。我们电子商务限界上下文根本不需要了解游戏上下文。

## 特征

领域事件通常是**不可变的**，因为他们是过去某些内容的记录。除了事件的描述外，一个领域事件通常包含一个事件发生时刻的时间戳以及事件中涉及的实体标识。此外，一个领域事件通常具有单独的时间戳，来指示事件何时进入系统，以及输入事件的人员身份。领域事件本身的标识可以基于这些属性集。例如，如果同一个事件的两个实例到达一个节点，它们可以被视为相同。

领域事件的本质就是，你可以使用它来捕获应用中那么可以触发改变的事物，或者领域中其它应用中你感兴趣的改变。这些随后被处理的事件对象会导致系统的改变，并被存储在审记系统中。

### 命名约定

所有事件都必须用过去时动词表示，因为它们都在过去发生的。例如，`CustomerRelocated`， `CargoShipped`，或者 `InventoryLossageRecorded`。在英语中有一些有趣的例子，人们可能会倾向于使用名词，而不是过去时动词。例如一个对自然灾害感兴趣的国会议来说，"地震"或者"倾塌"就是相关事件。我们建议尽量避免在领域事件中使用类似名词的诱惑，而是坚持用动词的过去时态。

### 领域事件与通用语言

当我们讨论"重定位用户"的副作用时，请思考通用语言的不同。这个事件使概念变得明确，而以前，聚合或者多个聚合之间发生的改变会留下隐式的概念,这些都需要探索和定义。例如，在大多数系统中，当`Hibernate`或者实体框架这样的库上发生副作用时,它不会影响到领域。从客户端的角度来看,这些事件是隐式和透明的。事件的引入使概念变得明确，并使之成为通用语言的一部分。"重定位用户"不仅仅是改变某些内容,还会在语言中显式的产生`CustomerRelocatedEvent`事件。

### 不变性

正如我们提及过的，领域事件关注的是领域内过去发生的改变。根据定义，你不可能改变过去，除非你是`Marty McFly`并且有一个`DeLorean`（译者注：这里是《回到未来》电影里的角色）。因此，请记住领域事件是不可变的。

> `Symfony` 事件分派器
>  
> 一些 PHP 框架支持事件。不过，不要混淆这些事件与**领域事件**。它们在特征和目的上是不同的。例如，`Symfony`有 `Event Dispatcher` 组件，如果你需要为一个状态机实现一个事件系统，则可以依赖它。在`Symfony`中，在请求与响应的转换过程也是由事件处理。但是，`Symfony Events`是可变的，并且每个`listeners`侦听器都能够修改，添加或者更新事件中的信息。

## 事件建模

为了准确地描述你的领域业务，你需要与领域专家紧密合作，来定义通用语言。这需要使用领域事件，实体，值对象等等来完成领域概念。在对事件建模时，依据通用语言，在它们的限界上下文内去命名事件及它们的属性。如果一个事件是一个聚合上的命令执行操作的结果，则名称通常派生自执行的命令。事件名称必须反映事件过去的性质，这一点非常和重要。

让我们考虑**用户注册**功能。领域事件需要表示它。下面的代码显示了基本领域事件的最小接口：

```php
interface DomainEvent
{
    /**
     * @return DateTimeImmutable
     */
    public function occurredOn();
}
```

正如你所见，最小的必要信息就是`DateTimeImmutable`，这是为了知道事件是何时发生的。

现在让我们用下面的代码来建模**用户注册**事件。正如我们在上面提到的，事件名称必须是动词过去式，那么`UserRegistered`是个不错的选择：

```php
class UserRegistered implements DomainEvent
{
    private $userId;

    public function __construct(UserId $userId)
    {
        $this->userId = $userId;
        $this->occurredOn = new \DateTimeImmutable();
    }

    public function userId()
    {
        return $this->userId;
    }

    public function occurredOn()
    {
        return $this->occurredOn;
    }
}
```

## Doctrine 事件

## 持久化领域事件

### 事件存储

## 从领域模型中发布事件

### 从实体中发布事件

### 从领域或者应用服务中发布事件

### 领域事件发布者是怎样工作的

### 设置领域事件监听者

### 测试领域事件

## 广播事件给远程限界上下文

### 消息中间件

### 用 REST 同步领域服务

## 小结
