# 应用

应用层是将领域模型与查询或更改其状态的客户分离的层。应用服务是此层的构建块。正如 Vaughn Vernon 所说：“应用服务是领域模型的直接客户端。”你可以考虑把应用服务当作外部世界（HTML 表单，API 客户端，命令行，框架，UI 等等）与领域模型自身之间的连接点。考虑向外部展示系统的顶级用例，也许会有帮助。例如：“作为来宾，我想注册”，“作为以登录用户，我要购买产品”，等等。

在这一章，我们将解释怎样实现应用服务，理解命令模式（Command pattern）的角色，并且确定应用服务的职责。要这样做的话，让我们考虑一个注册新用户（signing up a new user）的用例。

从概念上讲，为注册新用户，我们必须：

- 从客户端获取电子邮箱（email）和密码（password）
- 检查电子邮箱（email）是否在使用
- 创建一个新用户（user）
- 将用户（user）添加到已有用户集合（user set）
- 返回我们刚创建的用户（user）

让我们开始干吧！

## 请求（Requests）

我们需要发送电子邮件（email）和密码（password）给应用服务。这有许多方法可以从客户端来做这样事情（HTML 表单，API 客户端，或者甚至命令行）。我们可以通过用方法签名发送一个标准的参数（email 和 password），或者构建并发送一个含有这些信息的数据结构。后面的这种方法，即发送 DTO，把一些有趣的功能拿到台面上。通过发送对象，可以在命令总线上对其进行序列化和排队。也可以添加类型安全和一些 IDE 帮助。

> 数据传输对象（Data Transfer Object）
>  
> DTO 是一种在过程之间转移数据的数据结构。不要把它误认为是一种全能的对象。DTO 除了存储和检索它自身数据（存取器），没有其他任何行为。DTO 是简单的对象，它不应该含有任何需要测试的业务逻辑。

正如 Vaughn Vernon 所说：

> 应用服务方法签名仅使用基本类型（整数，字符串等等），或者 DTO 作为这些方法的替代方法，更好的方法可能是设计命令对象（Command Object）。这不一定是正确或错误的方法，这主要取决于你的口味和目标。

一个含有应用服务所含数据的 DTO 实现可能像这样：

```php
namespace Lw\Application\Service\User;
class SignUpUserRequest
{
    private $email;
    private $password;

    public function __construct($email, $password)
    {
        $this->email = $email;
        $this->password = $password;
    }

    public function email()
    {
        return $this->email;
    }

    public function password()
    {
        return $this->password;
    }
}
```

正如你所见，SignUpUserRequest 没有行为，只有数据。这可能来自于一个 HTML 表单或者一个 API 端点，尽管我们不关心这些。

### 构建应用服务请求

从你最喜欢的框架交付机制创建一个请求，应该是最直观的。在 web 中，你可以将控制器请求中的参数打包成一个 DTO 并将它们下发给服务。对 CLI 命令来说也是相同的原则：读取输入参数并下发。

通过使用 Symfony，我们可以提取来自 HttpFoundation 组件的请求中的所需数据：

```php
// ...
class UsersController extends Controller
{
    /**
     * @Route('/signup', name = 'signup')
     * @param Request $request
     * @return Response
     */
    public function signUpAction(Request $request)
    {
// ...
        $signUpUserRequest = new SignUpUserRequest(
            $request->get('email'),
            $request->get('password')
        );
// ...
    }
// ...
```

在一个使用 Form 组件来捕获和验证参数的更精细的 Silex 应用程序上，它看起来像这样：

```php
// ...
$app->match('/signup', function (Request $request) use ($app) {
    $form = $app['sign_up_form'];
    $form->handleRequest($request);
    if ($form->isValid()) {
        $data = $form->getData();
        try {
            $app['sign_in_user_application_service']->execute(
                new SignUpUserRequest(
                    $data['email'],
                    $data['password']
                )
            );
            return $app->redirect(
                $app['url_generator']->generate('login')
            );
        } catch (UserAlreadyExistsException $e) {
            $form
                ->get('email')
                ->addError(
                    new FormError(
                        'Email is already registered by another user'
                    )
                );
        } catch (Exception $e) {
            $form
                ->addError(
                    new FormError(
                        'There was an error, please get in touch with us'
                    )
                );
        }
    }
    return $app['twig']->render('signup.html.twig', [
        'form' => $form->createView(),
    ]);
});
```

### 请求的设计

在设计你的请求对象时，你应该总是遵循这些原则：使用基本类型，序列化设计，并且不包含业务逻辑在里面。这样，你可以在单元测试时节省开支。

#### 使用基本类型

我们推荐使用基本类型来构建你的请求对象（就是字符串，整数，布尔值等等）。我们仅仅是抽象出输入参数。你应该能够从交付机制当中独立地消费应用服务。即使是非常复杂的 HTML 表单，也总是可以在控制器级别转换为基本类型。你应该不想混淆你的框架和业务逻辑。

在某些情况下，很容易直接使用值对象。不要这样做。值对象定义的更新将影响所有客户端，并且你会将客户端与领域逻辑耦合在一起。

#### 序列化

使用基本类型的一个副作用就是，任何请求对象可以轻松地序列化为字符串，发送并存储在消息系统或者数据库中。

#### 无业务逻辑

避免在你的请求对象中加入任何业务甚至验证逻辑。验证应该放到你的领域中（这里指的是实体，值对象，领域服务等等）。验证是保持业务不变性和领域约束的方法。

#### 无测试

应用程序请求是数据结构，不是对象。数据结构的单元测试就像测试 getters 和 setters。这没有行为需要测试，因此对请求对象和 DTO 进行单元测试没有太多价值。这些结构将作为更复杂的测试（例如集成测试或验收测试）的副作用而覆盖。

命令是请求对象的替代方法。我们设计一个具有多种应用方法服务，并且每个方法都含有你放到 Request 中的参数。对于简单的应用程序来说这是可以的，但后面我们就得操心这个问题。

## 应用服务剖析

当我们在请求中封装好了数据，就该处理业务逻辑了。正如 Vaughn Vernon 所说：“尽量保证应用服务很小很薄，仅仅用它们在模型上协调任务。”

首先要做的事情就是从请求中提取必要信息，即 email 和 password。必要的话，我们需要确认是否含有特殊 email 的用户。如果不关心这些的话，那么我们创建和添加用户到 UserRepository。在发现有用户具有相同 email 的特殊情况下，我们抛出一个异常以便客户端以自己的方式处理（显示错误，重试，或者直接忽略它）。

```php
namespace Lw\Application\Service\User;

use Ddd\Application\Service\ApplicationService;
use Lw\Domain\Model\User\User;
use Lw\Domain\Model\User\UserAlreadyExistsException;
use Lw\Domain\Model\User\UserRepository;

class SignUpUserService
{
    private $userRepository;

    public function __construct(UserRepository $userRepository)
    {
        $this->userRepository = $userRepository;
    }

    public function execute(SignUpUserRequest $request)
    {
        $email = $request->email();
        $password = $request->password();
        $user = $this->userRepository->ofEmail($email);
        if ($user) {
            throw new UserAlreadyExistsException();
        }
        $this->userRepository->add(
            new User(
                $this->userRepository->nextIdentity(),
                $email,
                $password
            )
        );
    }
}
```

漂亮！如果你想知道构造函数里的 UserRepository 是做什么的，我们会在后续向你展示。
> **处理异常**
>  
> 应用服务抛出异常是向客户端反馈不正常的情况和流程的方法。这一层上的异常与业务逻辑有关（像查找一个用户），但并不是实现细节（像 PDOException，PredisException, 或者 DoctrineException）。

### 依赖倒置

处理用户不是服务的职责。正如我们在**第 10 章，仓储**中所见，有一个专门的类来处理 User 集合：UserRepository。这是一个从应用服务到仓储的依赖。我们不想用仓储的具体实现耦合应用服务，因此这之后会导致我们用基础设施细节耦合服务。所以我们依赖具体实现依赖的契约（接口），即 UserRepository。

UserRepository 的特定实现会在运行时被构建和传送，例如用 DoctrineUserRepository，一个使用 Doctine 的专门实现。传递一个专门的实现在测试时同样正常。例如，NotAvailableUserRepository 可以是一个专门的实现，它会在一个操作每个执行时抛出一个异常。这样，我们可以测试所有应用服务行为，包括悲观路径（sad paths），即使当出现了问题，应用服务也必须正常工作。

应用服务也可以依赖领域服务（如 GetBadgesByUser）。在运行时，此类服务的实现可能相当复杂。可以想像一个通过 HTTP 协议整合上下文的 HttpGetBadgesByUser。

依赖抽象，我们可以使我们的应用服务不受底层基础设施更改的影响。

### 应用服务实例

仅实例化应用服务很容易，但根据依赖构建的复杂度，构建依赖树的可能很棘手。为此，大多数框架都带有依赖注入容器。如果没有，你最后会在控制器的某处得到类似以下的代码：

```php
$redisClient = new Predis\Client([
    'scheme' => 'tcp',
    'host' => '10.0.0.1',
    'port' => 6379
]);
$userRepository = new RedisUserRepository($redisClient);
$signUp = new SignUpUserService($userRepository);
$signUp->execute(new SignUpUserRequest(
    'user@example.com',
    'password'
));
```

我们决定为 UserRepository 使用 Redis 的实现。在之前的代码示例中，为构建一个在内部使用 Redis 的仓储，我们构建了所有所需的依赖项。

#### 自定义一个应用服务

### 执行

#### 一个类一个应用服务

#### 一个类多个应用服务方法

### 返回值

#### 来自聚合实例的 DTO

#### 数据转换器（Data Transformer）

### 复合层上的多个应用服务

#### AJAX 内容的集成

#### ESI 内容的集成

#### Symfony 子请求

#### 一个控制器（controller），多个应用服务

## 测试应用服务

## 事务

## 安全

## 领域事件

## 命令助手（Command Handlers）

## 战术库和其他选择

## 小结
