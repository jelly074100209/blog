# 用 PHP 实现六边形架构（Hexagonal Architecture）

以下文章由 Carlos Buenosvinos 于 2014 年 6 月 发布在 php architect 杂志。

## 引言

随着领域驱动设计（DDD）的兴起，促进领域中心化设计的架构变得越来越流行。六边形架构，也就是端口与适配器（Ports and Adapters），就是这种情况，PHP 开发人员似乎刚刚重新发现了它。六边形架构于 2005 年由敏捷宣言的作者之一 Alistair Cockburn 发明，它允许应用程序由用户，程序，自动化测试或批处理脚本平等驱动，并且可以独立于最终的运行时设备和数据库进行开发和测试。这使得不可知的 web 基础设施更易于测试，编写和维护。让我们看看如何使用真正的 PHP 示例来应用它。

你的公司正在建设一个叫做 Idy 的头脑风暴系统。用户添加 ideas 并且评级，因此最感兴趣的那个 idea 可以被公司实现。现在是星期一早上，另一个 sprint 开始了，并且你正与你的团队和产品经理在审查一些用户故事。**因为用户没有日志，我想对 idea 评级，并且作者应该被邮件通知**，这一点很重要，不是吗？

## 第一种方法

作为一个优秀的开发者，你决定分治这个用户故事，所以你将从第一部分，*I want to rate an idea* 开始。之后，你会面对 *the author should be notified by email*。这看下来像个计划。

就业务规则而言，对 ideas 评级，与在 ideas 仓储里通过其标识查询它一样容易，仓储含有所有 ideas，添加评级，重新计算平均值并将 ideas 保存回去。如果想法不存在或者仓储不可用，我们应该抛出异常，以便我们可以显示错误消息，重定向用户或执行业务要求我们执行的任何操作。

为了执行这个用例，我们仅需要 idea 标识和来自用户的评级。两个整数会来自用户请求。

你公司的 web 应用正在处理 Zend Framework 1 旧版程序。与大多数公司一样，应用程序中的某些部分可能是新开发的，更 SOLID（注：面向对象五大原则），而其他部分可能只是一个大泥球。但是，你知道使用什么框架是无关紧要的，重要的是编写干净的代码为公司带来低维护成本。

你试图应用上次会议中记得的一些敏捷原则，它是什么，是的，我记得是“make it work，make it right， make it fast”。经过一段时间的工作后，你将获得清单 1 所示的内容。

```php
class IdeaController extends Zend_Controller_Action
{
    public function rateAction()
    {
// Getting parameters from the request
        $ideaId = $this->request->getParam('id');
        $rating = $this->request->getParam('rating');
// Building database connection
        $db = new Zend_Db_Adapter_Pdo_Mysql([
            'host'
            => 'localhost',
            'username' => 'idy',
            'password' => '',
            'dbname'
            => 'idy'
        ]);
// Finding the idea in the database
        $sql = 'SELECT * FROM ideas WHERE idea_id = ?';
        $row = $db->fetchRow($sql, $ideaId);
        if (!$row) {
            throw new Exception('Idea does not exist');
        }
// Building the idea from the database
        $idea = new Idea();
        $idea->setId($row['id']);
        $idea->setTitle($row['title']);
        $idea->setDescription($row['description']);
        $idea->setRating($row['rating']);
        $idea->setVotes($row['votes']);
        $idea->setAuthor($row['email']);
// Add user rating
        $idea->addRating($rating);
// Update the idea and save it to the database
        $data = [
            'votes' => $idea->getVotes(),
            'rating' => $idea->getRating()
        ];
        $where['idea_id = ?'] = $ideaId;
        $db->update('ideas', $data, $where);
// Redirect to view idea page
        $this->redirect('/idea/' . $ideaId);
    }
}
```

我知道读者可能会想：谁直接通过控制器访问数据？这是一个 90 年代的例子吧！好好，你是对的。如果你已经在使用框架，则可能你也正在使用 ORM。可能是由你自己开发或者现有的（例如 Doctrine，Eloquent，Zend 等等）。在这种情况下，你与那些具有数据库连接对象但在孵化前不算鸡的人相比，要走得更远。

对于新手，清单 1 的代码正好可以工作。但是，如果你仔细看控制器（Controller），不仅看到业务规则，还看到 web 框架是怎样路由请求到你的业务规则，引用数据库或者怎样连接它。如此接近，你会看到对基础设施的引用。

基础设施是使你业务规则工作的细节。明显地，我们需要一些方式来获得它们（API，web，控制台应用等等）并且我们需要一些物理位置来存储我们的 ideas（内存，数据库，NoSQL等等）。但是，我们应该能够将这些组件中的任何一个行为相同但实现方式不同的组件交换。那么从数据库访问（Database access）开始怎样？

所有这些 Zend_DB_Adapter 连接（或者直接使用 MySQL 命令，如果需要的话）都要求提升为某种封装了获取和持久化 idea 对象的对象。他们要求成为仓储。

## 仓储和持久化边缘

无论业务规则还是基础设施发生变化，我们都需要编辑同一块代码。相信我，在计算机世界，你不希望很多人因不同原因接触同一块代码。试着让函数做一件事和仅做一件事，这样就不太可能让人弄乱相同的代码。你可以通过查看“单一职责原则（SRP）”了解更多信息。有关此原理的更多信息：<http://www.objectmentor.com/resources/articles/srp.pdf>

清单 1 明显是这种情况。如果我们想转移到 Redis 或者添加作者通知功能，你将不得不更新 rateAction 方法。与 rateAction 无关的几率很高。清单 1 的代码很脆弱。如果在你的团队经常听到：If it works，don‘t touch it，说明没有遵循 SRP。

因此，我们必须解耦代码并且封装处理查询和持久化 ideas 的职责到另一个对象。最好的方式，正如之前解释过，就是使用仓储。挑战接受！让我们看看清单 2：

```php
class IdeaController extends Zend_Controller_Action
{
    public function rateAction()
    {
        $ideaId = $this->request->getParam('id');
        $rating = $this->request->getParam('rating');
        $ideaRepository = new IdeaRepository();
        $idea = $ideaRepository->find($ideaId);
        if (!$idea) {
            throw new Exception('Idea does not exist');
        }
        $idea->addRating($rating);
        $ideaRepository->update($idea);
        $this->redirect('/idea/' . $ideaId);
    }
}

class IdeaRepository
{
    private $client;

    public function __construct()
    {
        $this->client = new Zend_Db_Adapter_Pdo_Mysql([
            'host' => 'localhost',
            'username' => 'idy',
            'password' => '',
            'dbname' => 'idy'
        ]);
    }

    public function find($id)
    {
        $sql = 'SELECT * FROM ideas WHERE idea_id = ?';
        $row = $this->client->fetchRow($sql, $id);
        if (!$row) {
            return null;
        }
        $idea = new Idea();
        $idea->setId($row['id']);
        $idea->setTitle($row['title']);
        $idea->setDescription($row['description']);
        $idea->setRating($row['rating']);
        $idea->setVotes($row['votes']);
        $idea->setAuthor($row['email']);
        return $idea;
    }

    public function update(Idea $idea)
    {
        $data = [
            'title' => $idea->getTitle(),
            'description' => $idea->getDescription(),
            'rating' => $idea->getRating(),
            'votes' => $idea->getVotes(),
            'email' => $idea->getAuthor(),
        ];
        $where = ['idea_id = ?' => $idea->getId()];
        $this->client->update('ideas', $data, $where);
    }
}
```

## 解耦业务和持久化

## 迁移持久化到 Redis

## 解耦业务和 Web 框架

## 用 API 评级 idea

## 控制台评级应用

## 评级 idea 测试用例

## 测试基础设施

## 头疼，这么多信赖！

## 领域服务和六边形通知边缘

## 一起概括

## 六边形架构

## 要点

## 下一步是什么
